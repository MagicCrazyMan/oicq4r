use p256::{
    ecdh::EphemeralSecret,
    elliptic_curve::{rand_core::OsRng, sec1::ToEncodedPoint},
    PublicKey,
};

static OICQ_PUBLIC_KEY: [u8; 65] = [
    0x04, 0xeb, 0xca, 0x94, 0xd7, 0x33, 0xe3, 0x99, 0xb2, 0xdb, 0x96, 0xea, 0xcd, 0xd3, 0xf6, 0x9a,
    0x8b, 0xb0, 0xf7, 0x42, 0x24, 0xe2, 0xb4, 0x4e, 0x33, 0x57, 0x81, 0x22, 0x11, 0xd2, 0xe6, 0x2e,
    0xfb, 0xc9, 0x1b, 0xb5, 0x53, 0x09, 0x8e, 0x25, 0xe3, 0x3a, 0x79, 0x9a, 0xdc, 0x7f, 0x76, 0xfe,
    0xb2, 0x08, 0xda, 0x7c, 0x65, 0x22, 0xcd, 0xb0, 0x71, 0x9a, 0x30, 0x51, 0x80, 0xcc, 0x54, 0xa8,
    0x2e,
];

#[derive(Debug)]
pub struct ECDH {
    pub share_key: [u8; 16],
    pub public_key: Vec<u8>,
}

impl ECDH {
    pub fn new() -> Self {
        let key_pair = EphemeralSecret::random(&mut OsRng);
        let share_key =
            key_pair.diffie_hellman(&PublicKey::from_sec1_bytes(&OICQ_PUBLIC_KEY).unwrap());
        let share_key = md5::compute(&share_key.raw_secret_bytes()[..16]).0;

        Self {
            share_key,
            public_key: key_pair
                .public_key()
                .as_affine()
                .to_encoded_point(false)
                .as_bytes()
                .to_vec(),
        }
    }
}
